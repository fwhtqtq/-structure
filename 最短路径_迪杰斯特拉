// 上述代码实现了迪杰斯特拉算法（Dijkstra Algorithm）用于在无向图中寻找两个节点之间的最短路径。以下是代码的逻辑：


// 首先定义了一个图的数据结构 Graph，其中包含一个二维数组 weight[][] 用于存储边的权重，以及一个表示节点数量的变量 numNodes。

// initGraph() 函数用于初始化图，将所有边的权重初始化为无穷大。

// addEdge() 函数用于向图中添加边，由于是无向图，边的权重需要同时更新两个方向。

// findMinDistance() 函数用于找到未访问顶点中距离最小的顶点，返回其索引。

// printShortestPaths() 函数用于打印最短路径，输出每个节点距离起始节点的最短距离。

// dijkstra() 函数用于实现迪杰斯特拉算法。首先初始化 distance[] 数组和 visited[] 数组，然后将起始节点到自身的距离设为0。接着进行 numNodes - 1 次循环，每次找到距离最小的未访问节点，并标记为已访问。然后更新与该节点相邻的节点的距离，如果通过该节点到达相邻节点的路径比已有路径短，则更新最短距离。最后调用 printShortestPaths() 函数输出最短路径。

// 在 main() 函数中，首先定义了节点数量 numNodes 和一个 Graph 类型的变量 graph。然后使用 initGraph() 初始化图，并使用 addEdge() 添加边。最后调用 dijkstra() 函数，传入起始节点的索引来计算最短路径。
// 总结起来，上述代码实现了使用迪杰斯特拉算法在无向图中寻找两个节点之间的最短路径。

#include <stdio.h>
#include <stdbool.h>
#define MAX_NODES 100
#define INFINITE 99999
// 图的邻接矩阵表示
typedef struct
{
    int weight[MAX_NODES][MAX_NODES];
    int numNodes;
} Graph;
// 初始化图
void initGraph(Graph *graph, int numNodes)
{
    graph->numNodes = numNodes;
    // 初始化所有边的权重为无穷大
    for (int i = 0; i < numNodes; i++)
    {
        for (int j = 0; j < numNodes; j++)
        {
            graph->weight[i][j] = INFINITE;
        }
    }
}
// 添加边
void addEdge(Graph *graph, int src, int dest, int weight)
{
    // 由于是无向图，边的权重需要同时更新两个方向
    graph->weight[src][dest] = weight;
    graph->weight[dest][src] = weight;
}
// 找到未访问顶点中距离最小的顶点
int findMinDistance(bool visited[], int distance[], int numNodes)
{
    int minDistance = INFINITE;
    int minIndex = -1;
    for (int i = 0; i < numNodes; i++)
    {
        if (!visited[i] && distance[i] < minDistance)
        {
            minDistance = distance[i];
            minIndex = i;
        }
    }
    return minIndex;
}
// 输出最短路径
void printShortestPaths(int distance[], int startNode, int numNodes)
{
    printf("Node\tDistance from Start Node\n");
    for (int i = 0; i < numNodes; i++)
    {
        printf("%d\t%d\n", i, distance[i]);
    }
}
// Dijkstra算法
void dijkstra(Graph *graph, int startNode)
{
    int numNodes = graph->numNodes;
    int distance[MAX_NODES];     // 存储起始节点到各个节点的最短距离
    bool visited[MAX_NODES];     // 记录节点是否被访问过
    // 初始化distance数组和visited数组
    for (int i = 0; i < numNodes; i++)
    {
        distance[i] = INFINITE;
        visited[i] = false;
    }
    // 起始节点到自身的距离为0
    distance[startNode] = 0;
    // 遍历所有未访问的节点
    for (int i = 0; i < numNodes - 1; i++)
    {
        // 找到距离最小的未访问节点
        int minNode = findMinDistance(visited, distance, numNodes);
        // 标记该节点为已访问
        visited[minNode] = true;
        // 更新所有与该节点相邻的节点的距离
        for (int j = 0; j < numNodes; j++)
        {
            if (!visited[j] && graph->weight[minNode][j] != INFINITE &&
                distance[minNode] + graph->weight[minNode][j] < distance[j])
            {
                distance[j] = distance[minNode] + graph->weight[minNode][j];
            }
        }
    }
    // 输出最短路径
    printShortestPaths(distance, startNode, numNodes);
}
// int main()
// {
    // int numNodes = 6; // 节点数量
    // Graph graph;
    // initGraph(&graph, numNodes);
    //添加边
    // addEdge(&graph, 0, 1, 2);
    // addEdge(&graph, 0, 2, 4);
    // addEdge(&graph, 1, 2, 1);
    // addEdge(&graph, 1, 3, 7);
    // addEdge(&graph, 2, 4, 3);
    // addEdge(&graph, 3, 4, 2);
    // addEdge(&graph, 3, 5, 1);
    // addEdge(&graph, 4, 5, 5);
    // int startNode = 0; // 起始节点
    // dijkstra(&graph, startNode);
    // return 0;
// }

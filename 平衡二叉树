#include <stdio.h>
#include <stdlib.h>
// 定义二叉树节点结构
typedef struct Node {
    int data;
    struct Node* left;
    struct Node* right;
    int height;
} Node;
// 获取节点的高度
int getHeight(Node* node) {
    if (node == NULL) {
        return 0;
    }
    return node->height;
}
// 获取两个整数的最大值
int max(int a, int b) {
    return (a > b) ? a : b;
}
// 创建节点
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    newNode->height = 1;
    return newNode;
}
// 获取节点的平衡因子
int getBalanceFactor(Node* node) {
    if (node == NULL) {
        return 0;
    }
    return getHeight(node->left) - getHeight(node->right);
}
// 对节点进行左旋操作
Node* leftRotate(Node* node) {
    Node* newRoot = node->right;
    Node* subtree = newRoot->left;
    // 左旋操作
    newRoot->left = node;
    node->right = subtree;
    // 更新节点的高度
    node->height = max(getHeight(node->left), getHeight(node->right)) + 1;
    newRoot->height = max(getHeight(newRoot->left), getHeight(newRoot->right)) + 1;
    return newRoot;
}
// 对节点进行右旋操作
Node* rightRotate(Node* node) {
    Node* newRoot = node->left;
    Node* subtree = newRoot->right;
    // 右旋操作
    newRoot->right = node;
    node->left = subtree;
    // 更新节点的高度
    node->height = max(getHeight(node->left), getHeight(node->right)) + 1;
    newRoot->height = max(getHeight(newRoot->left), getHeight(newRoot->right)) + 1;
    return newRoot;
}
// 插入节点
Node* insertNode(Node* root, int data) {
    // 执行普通的二叉搜索树插入操作
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insertNode(root->left, data);
    } else if (data > root->data) {
        root->right = insertNode(root->right, data);
    } else {
        // 已经存在相同的节点值
        return root;
    }
    // 更新节点的高度
    root->height = max(getHeight(root->left), getHeight(root->right)) + 1;
    // 获取节点的平衡因子
    int balanceFactor = getBalanceFactor(root);
    // 进行平衡调整
    // 如果左子树的高度大于右子树的高度，并且插入节点在左子树的左侧，进行右旋操作
    if (balanceFactor > 1 && data < root->left->data) {
        return rightRotate(root);
    }
    // 如果右子树的高度大于左子树的高度，并且插入节点在右子树的右侧，进行左旋操作
    if (balanceFactor < -1 && data > root->right->data) {
        return leftRotate(root);
    }
    // 如果左子树的高度大于右子树的高度，并且插入节点在左子树的右侧，先进行左旋操作，再进行右旋操作
    if (balanceFactor > 1 && data > root->left->data) {
        root->left = leftRotate(root->left);
        return rightRotate(root);
    }
    // 如果右子树的高度大于左子树的高度，并且插入节点在右子树的左侧，先进行右旋操作，再进行左旋操作
    if (balanceFactor < -1 && data < root->right->data) {
        root->right = rightRotate(root->right);
        return leftRotate(root);
    }
    return root;
}
// 查找节点
Node* searchNode(Node* root, int data) {
    if (root == NULL || root->data == data) {
        return root;
    }
    if (data < root->data) {
        return searchNode(root->left, data);
    }
    return searchNode(root->right, data);
}
// 查找以node为根节点的最小节点
Node* findMin(Node* node) {
    while (node->left != NULL) {
        node = node->left;
    }
    return node;
}
// 删除节点
Node* deleteNode(Node* root, int data) {
    // 执行普通的二叉搜索树删除操作
    if (root == NULL) {
        return root;
    }
    if (data < root->data) {
        root->left = deleteNode(root->left, data);
    } else if (data > root->data) {
        root->right = deleteNode(root->right, data);
    } else {
        // 当前节点即为要删除的节点
        if (root->left == NULL && root->right == NULL) {
            // 当前节点为叶子节点，直接删除
            free(root);
            root = NULL;
        } else if (root->left == NULL) {
            // 当前节点只有右子树
            Node* temp = root;
            root = root->right;
            free(temp);
        } else if (root->right == NULL) {
            // 当前节点只有左子树
            Node* temp = root;
            root = root->left;
            free(temp);
        } else {
            // 当前节点有左右子树
            Node* temp = findMin(root->right);
            root->data = temp->data;
            root->right = deleteNode(root->right, temp->data);
        }
    }
    // 如果树为空，无需进行平衡调整
    if (root == NULL) {
        return root;
    }
    // 更新节点的高度
    root->height = max(getHeight(root->left), getHeight(root->right)) + 1;
    // 获取节点的平衡因子
    int balanceFactor = getBalanceFactor(root);
    // 进行平衡调整
    // 如果左子树的高度大于右子树的高度，并且左子树的平衡因子大于等于0，进行右旋操作
    if (balanceFactor > 1 && getBalanceFactor(root->left) >= 0) {
        return rightRotate(root);
    }
    // 如果右子树的高度大于左子树的高度，并且右子树的平衡因子小于等于0，进行左旋操作
    if (balanceFactor < -1 && getBalanceFactor(root->right) <= 0) {
        return leftRotate(root);
    }
    // 如果左子树的高度大于右子树的高度，并且左子树的平衡因子小于0，先进行左旋操作，再进行右旋操作
    if (balanceFactor > 1 && getBalanceFactor(root->left) < 0) {
        root->left = leftRotate(root->left);
        return rightRotate(root);
    }
    // 如果右子树的高度大于左子树的高度，并且右子树的平衡因子大于0，先进行右旋操作，再进行左旋操作
    if (balanceFactor < -1 && getBalanceFactor(root->right) > 0) {
        root->right = rightRotate(root->right);
        return leftRotate(root);
    }
    return root;
}
// 中序遍历二叉树(左-根-右)
void inorderTraversal(Node* root) {
    if (root != NULL) {
        inorderTraversal(root->left);
        printf("%d ", root->data);s
        inorderTraversal(root->right);
    }
}
// int main() {
    // Node* root = NULL;
    // 插入节点
    // root = insertNode(root, 5);
    // root = insertNode(root, 3);
    // root = insertNode(root, 7);
    // root = insertNode(root, 1);
    // root = insertNode(root, 4);
    // root = insertNode(root, 6);
    // root = insertNode(root, 8);
    // printf("Binary search tree in inorder: ");
    // inorderTraversal(root);
    // printf("\n");
    // 查找节点
    // int searchData = 4;
    // Node* searchResult = searchNode(root, searchData);
    // if (searchResult != NULL) {
        // printf("Node found: %d\n", searchResult->data);
    // } else {
        // printf("Node not found\n");
    // }
    // 插入节点
    // int insertData = 2;
    // root = insertNode(root, insertData);
    // printf("Binary search tree after inserting %d: ", insertData);
    // inorderTraversal(root);
    // printf("\n");
    // 删除节点
    // int deleteData = 7;
    // root = deleteNode(root, deleteData);
    // printf("Binary search tree after deleting %d: ", deleteData);
    // inorderTraversal(root);
    // printf("\n");
    // return 0;
// }

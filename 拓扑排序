#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#define MAX_NODES 100
typedef struct
{
    int *adjacencyMatrix[MAX_NODES];
    int numNodes;
    int indegree[MAX_NODES];
} Graph;
// 初始化图
void initGraph(Graph *graph, int numNodes)
{
    graph->numNodes = numNodes;
    // 初始化邻接矩阵
    for (int i = 0; i < numNodes; i++)
    {
        graph->adjacencyMatrix[i] = (int *)malloc(numNodes * sizeof(int));
        for (int j = 0; j < numNodes; j++)
        {
            graph->adjacencyMatrix[i][j] = 0;
        }
    }
    // 初始化入度为0
    for (int i = 0; i < numNodes; i++)
    {
        graph->indegree[i] = 0;
    }
}
// 添加边
void addEdge(Graph *graph, int src, int dest)
{
    graph->adjacencyMatrix[src][dest] = 1;
    graph->indegree[dest]++;
}
// 拓扑排序
void topologicalSort(Graph *graph)
{
    int numNodes = graph->numNodes;
    int result[MAX_NODES]; // 存储排序结果
    int resultIndex = 0;
    // 统计入度为0的节点
    int *queue = (int *)malloc(numNodes * sizeof(int));
    int front = 0;
    int rear = 0;
    for (int i = 0; i < numNodes; i++)
    {
        if (graph->indegree[i] == 0)
        {
            queue[rear++] = i;
        }
    }
    // 拓扑排序
    while (front != rear)
    {
        int node = queue[front++];
        result[resultIndex++] = node;
        // 将邻接节点的入度减1
        for (int i = 0; i < numNodes; i++)
        {
            if (graph->adjacencyMatrix[node][i] == 1)
            {
                graph->indegree[i]--;
                // 如果邻接节点的入度为0，则入队
                if (graph->indegree[i] == 0)
                {
                    queue[rear++] = i;
                }
            }
        }
    }
    // 检查是否存在环路
    if (resultIndex != numNodes)
    {
        printf("Graph contains a cycle. Topological sorting not possible.\n");
    }
    else
    {
        printf("Topological Sorting: ");
        for (int i = 0; i < numNodes; i++)
        {
            printf("%d ", result[i]);
        }
        printf("\n");
    }
    free(queue);
}
// int main()
// {
    // int numNodes = 6;
    // Graph graph;
    // initGraph(&graph, numNodes);
    //添加边
    // addEdge(&graph, 0, 1);
    // addEdge(&graph, 0, 3);
    // addEdge(&graph, 1, 2);
    // addEdge(&graph, 1, 3);
    // addEdge(&graph, 3, 2);
    // addEdge(&graph, 3, 4);
    // addEdge(&graph, 4, 2);
    // addEdge(&graph, 4, 5);
    //执行拓扑排序
    // topologicalSort(&graph);
    // return 0;
// }
